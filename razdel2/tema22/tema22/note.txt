Сортировка пузырьком /*обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы.
    В результате первого прохода на последнее место «всплывёт» максимальный элемент.
    Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего)
    и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте.
    Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива,
    запихивая найденные максимумы в конец.*/
Данный метод в настоящее время считается наиболее быстрым
универсальным методом сортировки. Как ни странно, он является обобщением
самого плохого из простейших методов – обменного метода. Эффективность
метода достигается тем, что перестановка применяется не для соседних
элементов, а отстоящих друг от друга на приличном расстоянии.
Более конкретно, алгоритм быстрой сортировки заключается в следующем.
x пусть каким-то образом в исходном наборе выделен некий элемент x,
который принято называть опорным. В простейшем случае в качестве
опорного можно взять серединный элемент массива
x просматривается часть массива, расположенная левее опорного элемента
и находится первый по порядку элемент ai > x
x после этого просматривается часть массива, расположенная правее
опорного элемента, причем - в обратном порядке, и находится первый
по порядку (с конца) элемент aj < x
x производится перестановка элементов ai и aj
x после этого в левой части, начиная с ai отыскивается еще один элемент,
больший x, а в правой части, начиная с aj отыскивается элемент,
меньший х
x эти два элемента меняются местами
x эти действия (поиск слева и справа с последующим обменом)
продолжаются до тех пор, пока не будет достигнут опорный элемент x
x после этого слева от опорного элемента x будут находиться элементы,
меньшие опорного, а справа – элементы, большие опорного. При этом
обе половины скорее всего не будут отсортированными
x после этого массив разбивается на правую и левую части и каждая часть
обрабатывается отдельно по той же самой схеме: определение опорного
элемента, поиск слева и справа соответствующих элементов и их
перестановка и т.д.




Сортировка вставками /*Проходим по массиву слева направо и обрабатываем по очереди каждый элемент.
    Слева от очередного элемента наращиваем отсортированную часть массива,
    справа по мере процесса потихоньку испаряется неотсортированная.
    В отсортированной части массива ищется точка вставки для очередного элемента. */
    //Сам элемент отправляется в буфер, в результате чего в массиве появляется свободная ячейка —
    //это позволяет сдвинуть элементы и освободить точку вставки.
Метод Шелла является улучшенным вариантом метода вставок. Поскольку
метод вставок дает хорошие показатели качества для небольших или почти
упорядоченных наборов данных, метод Шелла использует эти свойства за счет
многократного применения метода вставок.
Алгоритм метода Шелла состоит в многократном повторении двух
основных действий:
x объединение нескольких элементов исходного массива по некоторому
правилу
x сортировка этих элементов обычным методом вставок
Более подробно, на первом этапе группируются элементы входного
набора с достаточно большим шагом.
Например, выбираются все 1000-е
элементы, т.е. создаются группы:
группа 1: 1, 1001, 2001, 3001 и т.д.
группа 2: 2, 1002, 2002, 3002 и т.д.
группа 3: 3, 1003, 2003, 3003 и т.д.
. . . . . . . . . . . . . . . . . . . . .
группа 1000: 1000, 2000, 3000 и т.д.
Внутри каждой группы выполняется обычная сортировка вставками, что
эффективно за счет небольшого числа элементов в группе.
На втором этапе выполняется группировка уже с меньшим шагом,
например - все сотые элементы. В каждой группе опять выполняется обычная
сортировка вставками, которая эффективна за счет того, что после первого
этапа в каждой группе набор данных будет уже частично отсортирован.
На третьем этапе элементы группируются с еще меньшим шагом, например
– все десятые элементы. Выполняется сортировка, группировка с еще меньшим
шагом и т.д.
На последнем этапе сначала выполняется группировка с шагом 1,
создающая единственный набор данных размерности n, а затем - сортировка
практически отсортированного набора.
Фактор 1 (общий). Улучшенные методы показывают свою эффективность именно для больших наборов данных (сотни, тысячи и т.д. элементов).
Для очень малых наборов (как в примере) они могут давать даже худшие результаты.
Фактор 2 (специфический). Эффективность метода Шелла существенно зависит от выбора последовательности шагов группировки. 
Эта последовательность обязательно должна быть убывающей, а последний шаг обязательно равен 1. В настоящее время неизвестна наилучшая последовательность шагов, 
обеспечивающая наименьшую трудоемкость. На основе многочисленных экспериментов установлено, что число шагов группировки надо выбирать по формуле  [(log 2 n)] – 1


Сортировка выбором /*проходим по массиву в поисках максимального элемента.
    Найденный максимум меняем местами с последним элементом.
    Неотсортированная часть массива уменьшилась на один элемент (не включает последний элемент, куда мы переставили найденный максимум).
    К этой неотсортированной части применяем те же действия — находим максимум и ставим его на последнее место в неотсортированной части массива.
    И так продолжаем до тех пор, пока неотсортированная часть массива не уменьшится до одного элемента.*/
Пирамидальная сортировка является улучшенным вариантом сортировки
выбором, в которой на каждом шаге должен определяться наименьший элемент
в необработанном наборе данных. Поиск наименьшего элемента можно
совместить с выполнением некоторых дополнительных действий,
облегчающих поиск на последующих шагах. Для этого исходный набор данных
представляется особым образом – в виде так называемой пирамиды. Пирамида
– это специальная разновидность двоичного дерева, построенная по особым
правилам и имеющая особые свойства.
Пусть имеется исходный массив n элементов а1 а2, а3, . . ., аn. Расположим
эти элементы в виде двоичного дерева следующего вида (здесь важен порядок
следования индексов элементов):

Подобное дерево называется пирамидой, если для всех элементов с
индексами от 1 до n/2 выполняются следующие условия:
аi <= а2i и аi <= а2i+1
В частности, эти условия означают: а1 <= а2 и а1 <= а3; а2 <= а4 и а2 <=
а5; а3 <= а6 и а3 <= а7; а4 <= а8 и а4 <= а9, и т.д.

а1

а2 а3

а4 а5 а6 а7

а8 а9 а10 а11 а12 а13 а14 а15

135

Другими словами, в каждом элементарном поддереве значение в вершине
этого поддерева меньше или равно значений в вершинах-потомках.
     

