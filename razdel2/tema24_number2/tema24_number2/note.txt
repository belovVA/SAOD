Исходные элементы  а1, а2, а3, . . ., аn  распределяются некоторым специальным образом по ячейкам массива.
Для вычисления индекса ячейки по входному ключу используется специальная функция, называемая хеш-функцией.
Эта функция ставит в соответствие каждому ключу индекс ячейки массива, где должен располагаться элемент с этим ключом:
Массив, заполненный элементами исходного набора в порядке, определяемом хеш-функцией, называется хеш-таблицей.
Отсюда следует, что решение задачи поиска данным методом во многом зависит от используемой хеш-функции.
Предложено довольно много различных хеш-функций. 
Самой простой, но не самой лучшей хеш-функцией является функция взятия остатка от деления ключа нацело на  m:
h (аi ) = (аi  mod  m) + 1;
Ясно, что каждое значение этой функции лежит в пределах от 1 до m  и может приниматься в качестве индекса ячейки массива.
Принято считать, что хорошей является хеш-функция, которая удовлетворяет следующим условиям:
•	функция должна быть очень простой с вычислительной точки зрения
•	функция должна распределять ключи в хеш-таблице как можно более равномерно
Использование данного метода включает два этапа: 
•	построение хеш-таблицы для заданного набора ключей с помощью выбранной хеш-функции, т.е. определение для каждого ключа его местоположения в таблице
•	использование построенной таблицы для поиска элементов с помощью той же самой хеш-функции

Внутреннее хеширование для размещения конфликтующих ключей использует не вспомогательные списки,
а свободные ячейки хеш-таблицы. Для этого размер таблицы обязательно должен быть больше числа элементов (m>n). 
Если при построении хеш-таблицы для очередного ключа хеш-функция определяет некоторую ячейку j,
и эта ячейка оказывается занятой другим ключом, то предпринимается попытка найти в таблице свободную ячейку для размещения конфликтующего ключа. 
Если хотя бы одна свободная ячейка в таблице есть, то в ней и размещается конфликтующий ключ, в противном случае добавление считается невозможным.
Существуют различные правила поиска свободных мест для конфликтующих ключей.
Необходимо подчеркнуть, что правило выбора свободной ячейки должно быть одним и тем же как при построении таблицы, так и при использовании ее для поиска. 
Алгоритм построения хеш-таблицы:
•	находим значение хеш-функции для очередного ключа и по этому значению как индексу входим в таблицу
•	если данная клетка таблицы пустая, то записываем в нее соответствующий ключ
•	если ячейка занята, то сравниваем хранящийся там ключ с заданным ключом:
o	если ключи совпадают, то каким-то образом обрабатываем повторный ключ (например, просто ничего не выполняем)
o	если ключи не совпадают, то с помощью выбранного правила организуем циклический поиск свободной ячейки, который завершается либо при обнаружении свободной ячейки, либо по достижению конца цикла, что говорит об отсутствии в таблице свободных ячеек и невозможности добавления нового ключа
Алгоритм поиска:
•	находим значение хеш-функции для искомого ключа и по этому значению как индексу входим в таблицу
•	если ячейка с найденным индексом пустая, то поиск заканчивается неудачей
•	если ячейка не пустая, то выполняем сравнение ключей:
o	если ключи совпадают, то поиск заканчивается за одно сравнение
o	если ключи не совпадают, то с помощью выбранного правила организуем циклический просмотр ячеек,
который завершается либо при обнаружении свободной ячейки (поиск неудачен), либо по совпадению ключей (поиск удачен)
Эффективность внутреннего хеширования существенно зависит от наличия в хеш-таблице пустых ячеек,
поэтому на практике идут на искусственное увеличение размерности таблицы на. 10-20%  для обеспечения достаточного количества свободных клеток.
Многочисленные эксперименты показывают, что для заполненной на 50% таблицы (половина ячеек пустые) для поиска любого ключа 
в среднем требуется лишь 1,5 сравнения, причем это число не зависит от количества элементов. Это еще раз подтверждает высочайшую эффективность хеш-поиска!
